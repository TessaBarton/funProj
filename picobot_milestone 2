# Theresa Barton
# Picobot- room filling program optimization via genetic algorithm generation
# 9-12-13

# import libraries

import random
import math

# defined values

HEIGHT = 25
WIDTH = 25
NUMSTATES = 5

# classes
def valid(pattern):
    """ args: pattern (in form NxEx... ) where the capital letters are walls and the x's are empty squares
        outputs: list [] of direction strings ('N',....) for the rule.
        error handling
    """
    moves = []
    if 'x' in pattern:
        if pattern[0] == 'x':
            moves += 'N'
        if pattern[1] == 'x':
            moves += 'E'
        if pattern[2] == 'x':
            moves += 'W'
        if pattern[3] == 'x':
            moves += 'S'
        return moves
    else:
        print 'ERROR_IN_PATTERN' 

class Program:
    """ represents a single picobot program
    """
    def __init__(self):
        """sets self.rules to be an empty dictionary
        """
        self.rules = {}
        
    def __repr__(self):
        """returns a string representation of the program
        """
        keylist = self.rules.keys()
        keylist.sort()
        rulesstring = ''
        for i in keylist:
            var = self.rules[i]
            rulesstring += str(i[0]) + ' ' + str(i[1])  + '-->' + str(var[ 0 ]) + str(var[1])+'\n'
        return rulesstring


    def randomize(self):
        """ should generate a random, full set of rules for the dictionary, self.rules, basically
            it assigns random (legal) values to all possible keys.
        """
        startingstates = range(NUMSTATES + 1)    
        patterns = [ 'xxxx', 'Nxxx','NExx','NxWx','xxxS','xExS', 'xxWS', 'xExx','xxWx']
        for i in startingstates:
            for j in patterns:
                moves             = valid(j)
                move              = random.choice(moves)
                newstate          = random.choice(startingstates)
                self.rules[(i,j)] = (move,newstate)
    def getMove(self, state, surroundings):
        """ takes in integer state and surroundings ( 1, "xExx") and returns a
            tuple that contains the next move and the new state
        """
        newMove = self.rules[(state,surroundings)]
        return newMove

    def mutate(self):
        """ rewrites a randomly selected rule in the dictionary, changing the associated
            value
        """
        keylist     = self.rules.keys()
        i           = len(keylist)
        changekey   = random.choice(range(i+1))
        start       = keylist[changekey]
        pattern     = start[1]
        moves       = valid(pattern)
        move        = random.choice(moves)
        newstate    = random.choice(range(NUMSTATES+1))
        self.rules[changekey] = (move,newstate)
    ## need to write crossover still


class World:
    """ simulates a whole picobot enviroment, usually 25X25 empty room, and picobot robot
    """
    def __init__(self, initial_row, initial_col, program):
        """ contains information about where picobot is (row,col), the curent state
            for picobot (which will change) and a LOL that hods the 2d room
            and program, which tells us which program is directing picobots actions
            in the room
        """
        self.prow = initial_row
        self.pcol = initial_col
        self.state = 0
        self.prog = program
        self.room =[ [' ']*WIDTH for row in range(HEIGHT) ]
        for i in range(WIDTH):
            self.room[0][i]     = '-'
            self.room[HEIGHT-1][i]= '-'
        for i in range(HEIGHT):
            self.room[i][0]     = '|'
            self.room[i][WIDTH-1] = '|'
        self.room[0][0]         = '+'
        self.room[0][HEIGHT-1]    = '+'
        self.room[WIDTH-1][0]     = '+'
        self.room[WIDTH-1][HEIGHT-1]= '+'

    def __repr__(self):
        """shows the maze with the space character to unvisited cells, the walls with whatever
           character(s) you've chosen, the Picobot's position in
           the maze, and o (lower-case o) characters for empty but
           previously-visited locations in the maze.
        """
        # step method changes blanks to 'o's
        self.room[self.prow][self.pcol] = 'P'
        s = ''
        for row in range(HEIGHT):
            for col in range(WIDTH):
                s += self.room[row][col]
            s+= '\n'
        return s

    def getCurrentSurroundings(self):
        """ returs the surroundings ie walls or blanks of picobot
        """
        surroundings = ''
        if self.room[self.prow-1][self.pcol] ==  '-':
            surroundings += 'N'
        else:
            surroundings += 'x'
        if self.room[self.prow][self.pcol+1] == '|':
            surroundings += 'E'
        else:
            surroundings += 'x'
        if self.room[self.prow][self.pcol-1] == '|':
            surroundings += 'W'
        else:
            surroundings += 'x'
        if self.room[self.prow+1][self.pcol] ==  '-':
            surroundings += 'S'
        else:
            surroundings += 'x'
        
        
        return surroundings
        
        
    def step(self):
        """ moves picobot one step and updates self.room + self.row,self.col,
            self.state
        """
        self.room[self.prow][self.pcol] = 'o'
        sur     = self.getCurrentSurroundings()
        state   = self.state
        move    = self.prog.getMove(state,sur)
        self.state = move[1]
        if move[0] == 'N':
            self.prow -= 1
        if move[0] == 'E':
            self.pcol += 1
        if move[0] =='W':
            self.pcol -= 1
        if move[0] == 'S':
            self.prow += 1
        
        
    def run(self, steps):
        """inputs number of steps to move, executes that number of steps
        """
        while steps > 0:
            self.step()
            steps -= 1
            
        
        
        
                

    
    
